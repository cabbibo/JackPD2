#pragma kernel Set
#pragma kernel Collision
#pragma kernel Constraint


#pragma kernel BunnyForce


#include "../../Chunks/noise.cginc"
#include "../../Chunks/snoise.cginc"
#include "../../Chunks/curlNoise.cginc"


float4x4 transform; 

float _Delta;
float _Time;
uint _Pass;
float _PassMultiplier;

uint _NumVertsPerHair;
uint _HairsPerPoint;
float _HairLength;
float _HairVariance;

float3 _HandL;
float3 _HandR;

float _NoiseSize;
float _NoiseForce;
float _NoiseSpeed;
float _Dampening;
float _NormalForce;


struct Vert{
  float3 pos;
  float3 oPos;
  float3 nor;
  float3 tang;
  float2 uv;
  float2 debug;
};


struct Base{
    float3 pos;
  float3 vel;
  float3 nor;
  float3 tan;
  float2 uv;
  float used;
  float3 triIDs;
  float3 triWeights;
  float3 debug;
};

RWStructuredBuffer<Vert> _VertBuffer;
RWStructuredBuffer<Base> _BaseBuffer;

uint _VertBuffer_COUNT;
uint _BaseBuffer_COUNT;



#include "../../Chunks/safeID.cginc"

float3 getVel( float3 p1 , float3 p2 ){

  float3 v = p1 - p2;

  if( length( v ) > .5){ v = normalize( v ) *.5; }
  return v;
  
}

float3 springForce( float3 p1 , float3 p2 , float sl ){
  float3 dif = p1 - p2;
  float l = length(dif);

  if( l > 0 ){
    float d = l - sl;
    return normalize( dif ) * d;
  }else{
    return float3(0,0,0);
  }

}


#define NR_THREADS 128

[numthreads(NR_THREADS,1,1)]
void Set (uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {


  uint pID = id.x;//threadID + u3GroupID.x * NR_THREADS;
  uint bID = pID / _NumVertsPerHair;
  if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){


    pID = safeID( pID , _VertBuffer_COUNT );
    Vert vert = _VertBuffer[pID];
    Base base = _BaseBuffer[safeID( bID , _BaseBuffer_COUNT )];

  
    float3 bP = base.pos;
    float3 bN = base.nor;

    float l = float(pID % _NumVertsPerHair ) / float(_NumVertsPerHair);
    vert.uv = float2( l , float(bID)/float(_BaseBuffer_COUNT));

   
       
    vert.pos = bP;//bP + bN * _HairLength* l;
    vert.oPos = vert.pos;

    _VertBuffer[pID] = vert;

  }
  
}

float3 _Gravity;



[numthreads(NR_THREADS,1,1)]
void Collision (uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {

  //int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  uint pID = id.x;//threadID + u3GroupID.x * NR_THREADS;
  uint bID = pID / _NumVertsPerHair;
  if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){

    pID = safeID( pID , _VertBuffer_COUNT );
    bID = safeID( bID , _BaseBuffer_COUNT );
    Vert vert = _VertBuffer[pID];
    Base base = _BaseBuffer[bID];

    float3 bP = base.pos;
    float3 bN = base.nor;
    float2 bUV = base.uv;


    float3 force = 0;//float3(0,.4,0);

    force += bN * _NormalForce;
    force += curlNoise( vert.pos *_NoiseSize + float3(0,_Time*_NoiseSpeed,0) ) *_NoiseForce;

    force +=  _Gravity;

    // Inertia: objects in motion stay in motion.
    float3 vel = getVel( vert.pos , vert.oPos);

 
 
    bool tb = false;

   if( length( force ) > 10 ){
      force = normalize(force) * 10;
    //  vert.oPos = vert.pos;
      
  //    tb = true;
    }

    /*if( length(vert.pos) == 0 ){
      vert.pos  = bP + bN * vert.uv.x * _HairLength;;
      vert.oPos = vert.pos;
      tb = true;
    }*/



    // If we are at the bottom, 
    if( vert.uv.x < .1 ){ 
      vert.pos = bP; 
      vert.oPos = bP;
      tb = true;
      vert.nor = bN;
    }else{

       Vert vDown = _VertBuffer[ safeID( pID - 1 , _VertBuffer_COUNT )];
       vert.nor = normalize(vert.pos - vDown.pos);

       vert.tang = normalize( cross( vert.nor , float3(0,0,1) ) ) ;

    }

    if( length(vel) > 10 ){
      vel = normalize(vel) * 10;
     // vert.oPos = vert.pos;
      //tb = true;
    }

    if(tb == false ){

      float dampening = _Dampening;//.99999;// - vert.life * .01;
      float3 next = vert.pos + vel  * dampening+ force * .0001;

      vert.oPos = vert.pos;
      vert.pos = next;

    }
    vert.debug =  base.debug.xy;

  // vert.pos = bP + bN * vert.uv.x * _HairLength;


    _VertBuffer[pID] = vert;
    


  }
  
}



[numthreads(NR_THREADS,1,1)]
void Constraint(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {

  // Get the id using thread / group indices
  uint pID =  id.x;

  // Since we are doing 2 passes for verlet, multiply by 2 
  // to get both the vertices!
  pID = pID * 2;
  pID = pID + _Pass;

    uint bID = pID / _NumVertsPerHair;
bID = safeID( bID , _BaseBuffer_COUNT );
    Base base = _BaseBuffer[bID];


  float3 s = length(mul( transform , float4(1,1,1,0)).xyz)/3;
  if( pID < uint(_VertBuffer_COUNT) ){

    pID = uint(safeID(pID,_VertBuffer_COUNT));

    
    int pUp = uint(safeID(pID+1,_VertBuffer_COUNT));
    Vert v1 = _VertBuffer[pID];

    



    float n = sin(1000*float(pID/_NumVertsPerHair)); 

    // If we are are the end of the hair, no need to do verlet
    if( v1.uv.x <= 1-(2/ float(_NumVertsPerHair))){

    
      Vert v2 = _VertBuffer[pUp];

      float3 dif = v1.pos - v2.pos;


      float l = length( dif );// * ((4+n)/4);

      float difference = 0;
      
      // We want to make sure that l isn't zero, 
      // or we will get some NaNs
      if( l > 0.00001 ){
        difference = (((_HairLength)/float(_NumVertsPerHair))-l)/l;//((s*v1.debug.x/float(_NumVertsPerHair)) - l ) / l;
      }

      // Here is where the actual verlet goes down!
      float3 translate = dif * .6 * difference * _PassMultiplier;
      
      float3 t1 = 1 * translate;
      float3 t2 = 1 * translate;
      
      float3 n1 = v1.pos + t1;
      float3 n2 = v2.pos - t2;


       // move towards
        v1.pos = n1;
        v2.pos = n2;
        



     // Set both the values in the proper buffer location!
    _VertBuffer[ pID ] = v1;
    _VertBuffer[ pUp ] = v2;


    

    }



  }



}




[numthreads(NR_THREADS,1,1)]
void BunnyForce(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {

  //int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  uint pID = id.x;//threadID + u3GroupID.x * NR_THREADS;
  uint bID = pID / _NumVertsPerHair;
  if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){

    pID = safeID( pID , _VertBuffer_COUNT );
    bID = safeID( bID , _BaseBuffer_COUNT );
    Vert vert = _VertBuffer[pID];
    Base base = _BaseBuffer[bID];

    float3 bP = base.pos;
    float3 bN = base.nor;

    float3 force = float3(0,.4,0);

    force += bN *20;
    force += curlNoise( vert.pos *.01 + float3(0,_Time*.1,0) ) *11.4;

    // Inertia: objects in motion stay in motion.
    float3 vel = getVel( vert.pos , vert.oPos);

    if( length( force ) > 100 ){
      force = normalize(force) * 100;
    }
 
    bool tb = false;

    if( length(vert.pos) == 0 ){
      vert.pos  = bP + bN * vert.uv.x * _HairLength;
      vert.oPos = vert.pos;
      tb = true;
    }



    // If we are at the bottom, 
    if( vert.uv.x < .1 ){ 
      vert.pos = bP; 
      vert.oPos = bP;
      tb = true;
      vert.nor = bN;
    }else{

       Vert vDown = _VertBuffer[ safeID( pID - 1 , _VertBuffer_COUNT )];
       vert.nor = normalize(vert.pos - vDown.pos);

       vert.tang = normalize( cross( vert.nor , float3(0,0,1) ) ) ;

    }

    if(tb == false ){

      float dampening =.99;//_Dampening;//.99999;// - vert.life * .01;
      float3 next = vert.pos + vel  * dampening+ force * .01  ;

      vert.oPos = vert.pos;
      vert.pos = next;

    }
    vert.debug.xy = base.debug.xy;//_HairLength * ( _HairVariance * hash( float(pID)) + 1-_HairVariance );
   // vert.debug.y = (float)bID;//vert.debug.x;
   
    _VertBuffer[pID] = vert;

  }
  
}
